
将 DOM 事件添加到编辑器上

### 方案一：事件委托

在编辑器的根元素（Lexical 附加到的 contentEditable 元素）上设置监听器。

```jsx
const removeRootListener = editor.registerRootListener((rootElement, prevRootElement) => {
    // add the listener to the current root element
    rootElement.addEventListener('click', myListener);
    // remove the listener from the old root element - make sure the ref to myListener
    // is stable so the removal works and you avoid a memory leak.
    prevRootElement.removeEventListener('click', myListener);
});

// teardown the listener - return this from your useEffect callback if you're using React.
removeRootListener();
```

#### 命令模式：

直接在 DOM 事件监听器中调用 `editor.update()` 是一个**反模式**，因为它将底层的交互逻辑与编辑器状态更新逻辑紧密耦合在一起。

更好的模式是：**将 DOM 事件监听器作为“信号发射器”**。它的唯一职责是捕捉事件，阻止默认行为（如果需要），然后**分发一个 Lexical 命令**。

**示例：实现 `Cmd+K` 弹出链接编辑框**

1.  **定义命令**
    ```javascript
    import { createCommand } from 'lexical';
    export const TOGGLE_LINK_MODAL_COMMAND = createCommand('TOGGLE_LINK_MODAL_COMMAND');
    ```

2.  **创建监听器插件 (DOM Event Handler)**
    ```jsx
    // KeydownListenerPlugin.js
    useEffect(() => {
      const unregister = editor.registerRootListener((rootElement) => {
        const handleKeyDown = (event) => {
          if (event.key === 'k' && (event.metaKey || event.ctrlKey)) {
            event.preventDefault(); // 阻止浏览器默认行为 (如搜索)
            // 只分发命令，不处理具体逻辑
            editor.dispatchCommand(TOGGLE_LINK_MODAL_COMMAND, undefined);
          }
        };
        rootElement.addEventListener('keydown', handleKeyDown);
        return () => rootElement.removeEventListener('keydown', handleKeyDown);
      });
      return unregister;
    }, [editor]);
    ```

3.  **创建功能插件 (Command Handler)**
    ```jsx
    // LinkModalPlugin.js
    useEffect(() => {
      return editor.registerCommand(
        TOGGLE_LINK_MODAL_COMMAND,
        () => {
          // 在这里处理打开/关闭链接编辑框的 React state
          setLinkModalOpen(true);
          return true; // 命令已处理
        },
        COMMAND_PRIORITY_LOW
      );
    }, [editor]);
    ```

**这种模式的好处：**
-   **解耦**：监听键盘事件的插件和处理链接模态框的插件可以是两个完全独立的部分。
-   **可测试性**：你可以单独测试 `TOGGLE_LINK_MODAL_COMMAND` 是否能正确打开模态框，而无需模拟真实的键盘事件。
-   **可组合性**：其他任何插件也可以分发 `TOGGLE_LINK_MODAL_COMMAND` 来触发同样的行为。

### 方案二：NodeEventPlugin 对特定节点添加事件处理

```jsx
<LexicalComposer>
    <NodeEventPlugin
        nodeType={LinkNode}
        eventType={'click'}
        eventListener={(e: Event) => {
            alert('Nice!');
        }}
    />
</LexicalComposer>
```