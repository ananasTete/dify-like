

Update Tags 是附加到每次 EditorState 更新上的元数据，用于描述更新的来源或意图。
为了让监听器（尤其是插件）能够区分不同类型的更新，从而实现更精确、更健壮的逻辑，特别是为了避免无限循环和控制历史记录。


### 一个完整的例子：防止自动保存循环

假设你有一个自动保存插件，它监听编辑器更新，并将内容发送到服务器。同时，你还有一个功能，允许从外部（比如 WebSocket 消息）加载内容到编辑器中。

**问题**：当从外部加载内容时，会触发 `editor.update()`，这会让自动保存插件误以为是用户修改了内容，从而再次将同样的内容发回服务器。

**解决方案**：使用 `Update Tags`。

```jsx
// AutoSavePlugin.js
import { EXTERNAL_LOAD_TAG } from 'lexical';

useEffect(() => {
  const unregister = editor.registerUpdateListener(({ tags }) => {
    // 如果是外部加载的更新，则忽略
    if (tags.has(EXTERNAL_LOAD_TAG)) {
      return;
    }
    // 否则，执行自动保存
    debouncedSave();
  });
  return unregister;
}, [editor, debouncedSave]);


// 你的应用逻辑中，加载外部数据的地方
function loadContentFromServer(content) {
  const newEditorState = editor.parseEditorState(content);
  
  // 在设置新状态时，明确打上标签
  editor.setEditorState(newEditorState, { tag: EXTERNAL_LOAD_TAG });
}
```
通过这种方式，`AutoSavePlugin` 变得更加智能，它能够区分**“用户的编辑”**和**“程序的加载”**，避免了不必要的网络请求和潜在的逻辑冲突。

### 如何使用更新标签

```js
import {HISTORY_PUSH_TAG, PASTE_TAG} from 'lexical';

editor.update(() => {
  // Your update code
}, {
  tag: HISTORY_PUSH_TAG // Single tag
});

editor.update(() => {
  // Your update code
}, {
  tag: [HISTORY_PUSH_TAG, PASTE_TAG] // Multiple tags
});
```


```js
import {HISTORY_PUSH_TAG} from 'lexical';

editor.update(() => {
  $addUpdateTag(HISTORY_PUSH_TAG);
  // Your update code
});
```

```js
import {HISTORIC_TAG} from 'lexical';

editor.registerUpdateListener(({tags}) => {
  if (tags.has(HISTORIC_TAG)) {
    // Handle updates with historic tag
  }
});

editor.registerMutationListener(MyNode, (mutations) => {
  // updateTags contains tags from the current update
  if (mutations.updateTags.has(HISTORIC_TAG)) {
    // Handle mutations with historic tag
  }
});
```

### Lexical 提供了多个内置的更新标签，这些标签作为常量导出。

- HISTORIC_TAG: 表示更新与历史操作（撤销/重做）相关
- HISTORY_PUSH_TAG ：强制创建一个新的历史记录条目
- HISTORY_MERGE_TAG ：将当前更新与上一个历史记录条目合并
- PASTE_TAG : 表示更新与粘贴操作相关
- COLLABORATION_TAG : 表示更新与协同编辑相关

### 也可以自定义常量来实现自定义更新标签

```js
// Define your custom tags as constants
const MY_FEATURE_TAG = 'my-custom-feature';
const MY_UPDATE_TAG = 'my-custom-update';

editor.update(() => {
    // ...
}, {
  tag: MY_UPDATE_TAG
});

// Listen for updates with specific tags
editor.registerUpdateListener(({tags}) => {
  if (tags.has(MY_FEATURE_TAG)) {
    // Handle updates from your custom feature
  }
});
```