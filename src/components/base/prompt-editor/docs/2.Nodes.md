

如果说 `EditorState` 是编辑器的“完整快照”，那么 **`Node` 就是构成这张快照的“基本像素点”或“乐高积木”**。编辑器中的每一个段落、每一段文字、每一张图片，都是一个或多个节点组成的。

---

### 一、核心理念：万物皆节点

在 Lexical 中，所有内容都被抽象为节点。这种设计带来了极大的灵活性和可扩展性。

**与 HTML DOM 的类比是理解节点最快的方式：**

| Lexical 节点 | 对应的 HTML DOM 概念 |
| :--- | :--- |
| **`RootNode`** | 类似于 `<body>` 标签，是所有内容的顶层容器。 |
| **`ElementNode`** | 类似于 `<div>`, `<p>`, `<h1>`, `<ul>` 等块级或行内元素。它们是**容器**，可以包含其他节点。 |
| **`TextNode`** | 类似于 DOM 中的文本节点。它们是**内容的载体**，持有实际的文本字符串和格式信息。 |
| **`DecoratorNode`** | 这是一个特殊概念，可以看作是让你嵌入一个“黑盒”组件（如 React 组件）的**占位符**。 |

---

### 二、主要的节点类型详解

Lexical 的节点是一个面向对象的类体系，所有节点都继承自一个基类 `LexicalNode`。下面我们来详细了解几个最重要的子类。

#### 1. `RootNode` (根节点)

-   **角色**：编辑器的“始祖”。
-   **特点**：
    -   每个编辑器状态树中有且仅有一个 `RootNode`。
    -   它位于树的最顶端，是所有其他节点的祖先。
    -   你无法删除它。
-   **如何访问**：在 `editor.update()` 中使用 `const root = $getRoot();`。

#### 2. `ElementNode` (元素节点)

-   **角色**：内容的“组织者”和“容器”。
-   **特点**：
    -   可以包含子节点（其他 `ElementNode`、`TextNode` 或 `DecoratorNode`）。
    -   它们定义了内容的结构。
    -   常见的内置 `ElementNode` 有：
        -   `ParagraphNode` (段落)
        -   `HeadingNode` (标题 H1, H2...)
        -   `ListNode` (列表 `<ul>` 或 `<ol>`)
        -   `ListItemNode` (列表项 `<li>`)
        -   `LinkNode` (链接 `<a>`)
-   **示例**：一个段落就是一个 `ParagraphNode`，它里面可能包含一个或多个 `TextNode`。

#### 3. `TextNode` (文本节点)

-   **角色**：实际文本的“持有者”。
-   **特点**：
    -   是树的**叶子节点**，不能再包含任何子节点。
    -   **核心属性**：
        -   **`text`**: 节点的文本内容字符串。
        -   **`format`**: 一个数字（位掩码），用来高效地存储文本格式，如粗体、斜体、下划线等。
        -   **`style`**: 一个字符串，用于存储内联 CSS 样式，如 `color: red;`。
        -   **`mode`**: 文本的特殊模式，如 `token` (不可编辑的片段), `segmented` (用于处理复杂输入法，如中文拼音)。
-   **示例**：在 "Hello **world**" 中，"Hello " 是一个 `TextNode`，"**world**" 是另一个 `TextNode`，后者的 `format` 属性标记了“粗体”。

#### 4. `DecoratorNode` (装饰器节点)

-   **角色**：用于渲染复杂、非文本内容的“特殊窗口”。
-   **特点**：
    -   它本身不直接负责渲染，而是**委托给一个外部组件（通常是 React 组件）**。
    -   它是**只读**的，用户不能直接在其中输入文字。
    -   非常适合用来实现高度自定义和交互性的内容。
-   **使用场景**：
    -   插入一张图片 (`ImageNode`)
    -   `@` 提及用户 (`MentionNode`)
    -   插入一个投票、视频播放器或公式编辑器。
    -   一条水平分割线 (`HorizontalRuleNode`)
-   **工作原理**：当 Lexical 渲染一个 `DecoratorNode` 时，它会在 DOM 中创建一个空的 `div` 作为挂载点，然后调用你提供的 `decorate()` 方法，该方法返回一个 React 组件，Lexical 会将这个组件渲染到那个 `div` 中。

---

### 三、节点的关键特性

1.  **唯一的 Key**：
    -   每个节点实例都有一个唯一的字符串 `key`。
    -   这个 `key` 在节点的整个生命周期中保持不变。
    -   Lexical 的协调算法（diffing）使用这个 `key` 来高效地识别节点的增、删、改，类似于 React 列表中的 `key` prop。

2.  **不可变性 (Immutability)**：
    -   与 `EditorState` 一样，节点也是不可变的。
    -   当你需要修改一个节点时（例如，改变一个 `TextNode` 的文本），你不能直接在旧节点上修改。
    -   在 `editor.update()` 内部，Lexical 会给你一个该节点的**可写副本 (writable copy)**。你对这个副本进行修改，当更新完成后，它会成为新 `EditorState` 中的一部分。
    -   例如，`node.getTextContent()` 获取当前文本，而 `node.getWritable().setTextContent('new text')` 则是获取可写副本并修改它。

3.  **可序列化 (Serializable)**：
    -   每个节点都知道如何将自己转换成一个 JSON 对象（通过 `exportJSON` 方法），以及如何从 JSON 对象中恢复自己（通过 `importJSON` 静态方法）。
    -   这是实现**保存和加载编辑器内容**功能的基础。整个 `EditorState` 的序列化就是递归调用其下所有节点的序列化方法。

---

### 四、如何使用和操作节点

所有对节点的操作都必须在 `editor.update()` 的回调函数中进行。Lexical 提供了一套以 `$` 开头的辅助函数，用于在当前更新事务的上下文中安全地操作节点。

-   **创建节点**：
    -   `$createParagraphNode()`, `$createTextNode('some text')` 等。

-   **获取节点**：
    -   `$getRoot()`: 获取根节点。
    -   `$getNodeByKey(key)`: 通过 key 获取节点。
    -   `$getSelection()`: 获取当前选区信息，从中可以得到选中的节点。

-   **修改节点** (这些方法都在节点实例上)：
    -   `.append(childNode)`: 在节点末尾添加一个子节点。
    -   `.replace(nodeToReplace)`: 替换当前节点。
    -   `.remove()`: 删除当前节点。
    -   `.select()`: 选中整个节点。
    -   `.setTextContent('new text')`: (仅 `TextNode`) 设置文本内容。

**重要约定**：带有 `$` 前缀的函数，如 `$getRoot()`，是一个重要约定，它意味着这个函数正在访问当前事务中的“草稿状态”，因此**只能在 `editor.update()` 的回调函数中使用**。

### 五、为什么要自定义节点？

这是 Lexical 最强大的地方。当内置节点无法满足你的业务需求时，你可以创建自己的节点。

-   **场景**：你需要一个“产品卡片”组件，包含图片、标题和价格。
-   **实现**：你可以创建一个 `ProductCardNode`，它继承自 `ElementNode` 或 `DecoratorNode`。
    -   在节点类中定义卡片所需的数据（如 `productId`, `imageUrl`）。
    -   实现 `createDOM` 方法来定义它在 DOM 中应该渲染成什么样子。
    -   实现 `updateDOM` 方法来处理数据变化时的 DOM 更新。
    -   实现序列化方法 (`export/importJSON`)，以便保存和加载。
    -   最后，在编辑器的初始配置中**注册**你的自定义节点。

### 总结

| 节点类型 | 角色 | 类比 | 关键点 |
| :--- | :--- | :--- | :--- |
| **`RootNode`** | 顶级容器 | `<body>` | 唯一、必须存在 |
| **`ElementNode`** | 结构组织者 | `<p>`, `<h1>`, `<div>` | 可包含子节点，定义结构 |
| **`TextNode`** | 内容持有者 | DOM 文本 | 包含文本和格式，是叶子节点 |
| **`DecoratorNode`** | 特殊内容窗口 | React 组件占位符 | 渲染自定义组件，通常只读 |

理解了节点体系，你就掌握了控制 Lexical 编辑器内容结构和表现形式的钥匙。你可以通过组合、修改和自定义节点，来构建出任何你想要的富文本编辑体验。