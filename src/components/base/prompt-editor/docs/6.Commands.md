基于发布/订阅模式的通信机制，用于在编辑器的不同部分之间传递“意图”或“指令”。

### 命令系统的三大核心操作

命令系统的生命周期包含三个步骤：**定义、监听、分发**。

#### 1. 定义命令 (Define a Command)

首先，你需要创建一个命令。命令本身只是一个唯一的标识符，像是一个广播的“频道名称”。

```javascript
import { createCommand } from 'lexical';

// 创建一个不带参数的命令
export const CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');

// 创建一个需要携带参数（payload）的命令
// 泛型 <string> 定义了 payload 的类型
export const INSERT_IMAGE_COMMAND = createCommand<string>('INSERT_IMAGE_COMMAND');
```
`createCommand()` 返回一个唯一的对象，你将在监听和分发时使用它。

#### 2. 监听命令 (Listen for a Command)

插件或 UI 组件使用 `editor.registerCommand()` 来订阅一个命令。

```javascript
// 在一个插件的 useEffect 中
useEffect(() => {
  // 注册监听器，返回一个 unregister 函数用于清理
  const unregister = editor.registerCommand(
    CLEAR_EDITOR_COMMAND, // 1. 要监听的命令
    (payload) => {         // 2. 回调函数，处理命令
      editor.update(() => {
        const root = $getRoot();
        root.clear();
      });
      // 返回 true 表示“命令已被我处理，停止传播”
      return true;
    },
    COMMAND_PRIORITY_NORMAL // 3. 优先级
  );

  return () => unregister(); // 组件卸载时清理
}, [editor]);
```

**关键参数解析：**
-   **回调函数**：当命令被分发时执行。它的返回值非常重要：
    -   `return true;`: 表示这个监听器已经**完全处理**了该命令。命令的传播将在此停止，不会再通知其他优先级更低的监听器。
    -   `return false;`: 表示这个监听器**没有处理**（或者只是部分处理）该命令。命令将继续传播给下一个优先级较低的监听器。
-   **优先级 (Priority)**：决定了监听器的执行顺序。当一个命令被分发时，Lexical 会按照从高到低的优先级依次调用所有监听该命令的回调。
    -   `COMMAND_PRIORITY_CRITICAL` (最高)
    -   `COMMAND_PRIORITY_HIGH`
    -   `COMMAND_PRIORITY_NORMAL`
    -   `COMMAND_PRIORITY_LOW`
    -   `COMMAND_PRIORITY_EDITOR` (最低, 通常用于 Lexical 核心功能)

    **优先级系统非常强大**。它允许你用一个高优先级的监听器来**拦截**并覆盖 Lexical 的默认行为。

#### 3. 分发命令 (Dispatch a Command)

在你的应用中的任何地方（通常是 UI 事件处理函数中），你都可以使用 `editor.dispatchCommand()` 来触发一个命令。

```jsx
// 在你的 React 工具栏组件中
function Toolbar() {
  const [editor] = useLexicalComposerContext();

  const handleClearClick = () => {
    // 分发 CLEAR_EDITOR_COMMAND 命令
    editor.dispatchCommand(CLEAR_EDITOR_COMMAND, undefined);
  };

  const handleInsertImage = (imageUrl) => {
    // 分发带 payload 的命令
    editor.dispatchCommand(INSERT_IMAGE_COMMAND, imageUrl);
  };

  return (
    <div>
      <button onClick={handleClearClick}>Clear Editor</button>
      {/* ... */}
    </div>
  );
}
```

---

### 三、命令 vs. 直接 `editor.update`

你可能会问：为什么不直接在按钮的 `onClick` 里调用 `editor.update()` 呢？

| 操作方式 | `editor.dispatchCommand()` | 直接 `editor.update()` |
| :--- | :--- | :--- |
| **耦合度** | **低 (解耦)** | **高 (紧耦合)** |
| **关注点** | **意图 (Intent)**: “我想要加粗” | **实现 (Implementation)**: “我要获取选区，遍历节点，设置格式...” |
| **可扩展性**| **高**，任何插件都可以监听并参与。| **低**，逻辑被写死在调用处。|
| **适用场景**| 跨组件/插件通信，实现可复用、可拦截的功能。| 在一个插件**内部**，当监听到命令后，执行具体的状态修改。|

**最佳实践**：**外部（如 UI）通过分发命令来表达意图，内部（插件）通过监听命令并在 `editor.update` 中执行状态变更来实现意图。**

### 总结

| 概念 | 类比 | 解释 |
| :--- | :--- | :--- |
| **Command** | **广播频道名称 / API 端点** | 一个用于识别特定操作的唯一标识符。 |
| **`dispatchCommand`** | **发布广播 / 调用 API** | 向整个编辑器系统宣告一个意图，并可附带数据。 |
| **`registerCommand`** | **收听广播 / 定义 API 处理器** | 订阅一个意图，并在其发生时执行相应的逻辑。 |
| **Priority** | **VIP 通道 / 中间件顺序** | 定义了当多个监听器订阅同一个命令时，谁先执行，谁后执行。 |
| **`return true`** | **“这个请求我处理了，到此为止”** | 阻止命令继续传播，实现了拦截和覆盖。 |

命令系统是 Lexical 插件化、模块化架构的基石。通过它，你可以构建出功能强大、易于维护和扩展的复杂编辑器，而不会让代码变成一团乱麻。
