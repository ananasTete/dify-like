
节点转换就是当一类节点在被创建或者发生变化时，触发回调来修改它或者他的邻居节点。比如修改节点属性、合并相邻节点、拆分节点、移动节点、新增删除节点等类似 DOM 的操作。

场景一：markdown 编辑器的语法自动转换为对应节点

如实现将markdown标题语法(#)转为标题节点

```jsx
// 假设这是在一个 React 组件（插件）中
import { useEffect } from 'react';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { $createHeadingNode, HeadingNode } from '@lexical/rich-text';
import { $getSelection, $isRangeSelection, TextNode } from 'lexical';

export function MarkdownHeadingsPlugin() {
  const [editor] = useLexicalComposerContext();

  useEffect(() => {
    // 注册一个针对 TextNode 的转换器
    const unregister = editor.registerNodeTransform(TextNode, (textNode) => {
      const parent = textNode.getParent();
      const text = textNode.getTextContent();

      // 条件1: 必须是 "## " 开头
      if (!text.startsWith('## ')) {
        return;
      }
      
      // 条件2: 必须发生在一行的开头
      // textNode.getPreviousSibling() 为 null 意味着它是父节点里的第一个子节点
      if (textNode.getPreviousSibling() !== null) {
        return;
      }

      // 条件3: 确保光标就在 "## " 之后，避免误触发
      const selection = $getSelection();
      if (!$isRangeSelection(selection) || !selection.isCollapsed()) {
        return;
      }
      // 检查光标位置是否在触发文本的末尾
      if (selection.anchor.key !== textNode.getKey() || selection.anchor.offset !== 3) {
        return;
      }
      
      // --- 所有条件满足，开始替换 ---
      
      // 1. 创建一个新的 H2 标题节点
      const headingNode = $createHeadingNode('h2');
      
      // 2. 移除触发文本 "## "，只保留后面的内容
      textNode.setTextContent(text.substring(3));

      // 3. 将修改后的 textNode 移动到新的 headingNode 中
      headingNode.append(textNode);
      
      // 4. 用新的 headingNode 替换掉原来的整个段落 (parent)
      parent.replace(headingNode);

      // 5. 将光标移动到新标题的开头
      headingNode.selectStart();
    });

    return () => {
      unregister(); // 组件卸载时，清理监听器
    };
  }, [editor]);

  return null;
}
```

场景二：一个 ListNode (列表) 永远不应该是空的。如果它变空了，它应该自动变回一个普通的段落。

```jsx
// 插件代码
editor.registerNodeTransform(ListNode, (listNode) => {
  // 条件：如果列表节点的子节点数量为 0
  if (listNode.getChildrenSize() === 0) {
    // 动作1：创建一个新的段落节点
    const paragraph = $createParagraphNode();
    // 动作2：用这个新段落替换掉当前的空列表节点
    listNode.replace(paragraph);
    // 动作3（可选但推荐）：将光标移动到新段落中，提供良好的用户体验
    paragraph.select();
  }
});
```

场景三：合并两个相邻的、格式完全相同的 TextNode

`ParagraphNode -> TextNode("Hello ", {bold}) -> TextNode("world", {bold})`
变为
`ParagraphNode -> TextNode("Hello world", {bold})`

```jsx
editor.registerNodeTransform(TextNode, (textNode) => {
  const prevSibling = textNode.getPreviousSibling();
  
  // 条件1: 存在前一个兄弟节点
  // 条件2: 前一个兄弟节点也是一个 TextNode
  // 条件3: 两个节点的格式完全相同
  if (prevSibling instanceof TextNode && prevSibling.getFormat() === textNode.getFormat()) {
    // 动作1: 将当前节点的文本追加到前一个节点
    const writablePrevSibling = prevSibling.getWritable();
    writablePrevSibling.append(textNode.getTextContent());
    
    // 动作2: 删除当前节点
    textNode.remove();
  }
});
```

场景四：一个 ImageNode 必须始终被一个 FigureNode 包裹，以便添加图注 (caption)。

```jsx
editor.registerNodeTransform(ImageNode, (imageNode) => {
  const parent = imageNode.getParent();
  
  // 条件：如果图片的父节点不是 FigureNode
  if (!(parent instanceof FigureNode)) {
    // 动作1: 创建一个新的 FigureNode
    const figureNode = $createFigureNode();
    
    // 动作2: 在图片节点的位置，用 FigureNode 替换掉它
    imageNode.replace(figureNode);
    
    // 动作3: 将原始的图片节点作为子节点添加到新的 FigureNode 中
    figureNode.append(imageNode);
  }
});
```