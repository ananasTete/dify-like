### 一、核心理念：编辑器状态的“GPS坐标”

如果说 `EditorState` 是整个编辑内容的“地图”，那么 `Selection` 就是这张地图上的“GPS坐标”。它告诉 Lexical：

-   用户当前关注的**位置**在哪里。
-   用户意图操作的**范围**是多大。

无论是插入文字、设置格式（加粗、斜体），还是删除内容，Lexical 都需要首先查询 `Selection` 来确定操作的目标。

**关键特性：**
`Selection` 对象是**不可变的 (Immutable)**，并且是 `EditorState` 的一部分。当用户的光标移动或选择范围变化时，Lexical 会创建一个包含**新的 `Selection` 对象**的**新的 `EditorState`**。

---

### 二、`Selection` 的基本构成：锚点与焦点

一个 `Selection` 对象最核心的信息由两个“点”(Point) 构成：

1.  **`anchor` (锚点)**：选区的**起始点**。通常是你鼠标按下开始拖动的位置。
2.  **`focus` (焦点)**：选区的**结束点**。通常是你鼠标松开的位置。

这两个点共同定义了选区的范围和方向。

-   **当 `anchor` 和 `focus` 在同一个位置时**，它代表一个没有宽度的选区，视觉上表现为**光标 (Caret)**。
-   **当 `anchor` 和 `focus` 在不同位置时**，它代表一个有宽度的范围选择，视觉上表现为**高亮文本**。

#### Point 对象的结构

`anchor` 和 `focus` 本身都是一个包含精确位置信息的对象，其结构通常为：
`{ key: string, offset: number, type: 'text' | 'element' }`

-   **`key`**: 节点唯一的“身份证号”。它指明了选区的端点落在了**哪个节点**上。
-   **`offset`**: 偏移量。它的含义取决于 `type`：
    -   如果 `type` 是 **`'text'`** (端点在 `TextNode` 中)，`offset` 表示**字符索引**。例如，`offset: 3` 表示在第3个字符之后。
    -   如果 `type` 是 **`'element'`** (端点在 `ElementNode` 中)，`offset` 表示**子节点索引**。例如，`offset: 2` 表示在第2个子节点之后。

---

### 三、`Selection` 的主要类型

Lexical 根据选择内容的不同，定义了三种主要的 `Selection` 类型。在进行任何操作前，你都需要先判断当前是什么类型的选区。

#### 1. `RangeSelection` (范围选区)

-   **这是最常见、最普通的选区类型。**
-   它描述的是一段连续的内容范围，可以跨越多个节点。
-   无论是**光标 (Caret)** 还是**高亮文本**，都属于 `RangeSelection`。
-   你可以使用 `$isRangeSelection(selection)` 来进行类型判断。
-   它提供了丰富的方法，如：
    -   `selection.isCollapsed()`: 判断是否为光标（`anchor` 和 `focus` 是否重合）。
    -   `selection.getNodes()`: 获取选区范围内的所有节点。
    -   `selection.extract()`: 获取选区范围内的节点，并从原树中移除它们（剪切操作）。
    -   `selection.insertText('...')`: 在选区处插入文本。
    -   `selection.hasFormat('bold')`: 检查选区内的文本是否具有某种格式。

#### 2. `NodeSelection` (节点选区)

-   **当用户选择一个或多个“原子性”的块级节点时，就会产生节点选区。**
-   这些节点通常是 `DecoratorNode`（如图片、视频、水平分割线）或特殊的 `ElementNode`。
-   视觉上，被选中的节点通常会有一个蓝色的外框，而不是内部文本高亮。
-   你可以使用 `$isNodeSelection(selection)` 来进行类型判断。
-   它内部维护了一个被选中节点的 `key` 的集合。
-   这对于操作那些不能像文本一样被部分选择的“块”非常有用。

#### 3. `GridSelection` (网格选区)

-   **这是最特殊的选区，专门用于处理表格 (Table)。**
-   当用户在表格中拖动选择多个单元格时，就会创建 `GridSelection`。
-   它描述的是一个矩形范围内的所有表格单元格 (`TableCellNode`)。
-   你可以使用 `$isGridSelection(selection)` 来进行类型判断。

---

### 四、如何与 `Selection` 交互

与所有节点操作一样，对 `Selection` 的读写也**必须**在事务的回调函数中进行。

#### 1. 读取选区

使用 `$getSelection()` 函数来获取当前事务上下文中的 `Selection` 对象。

```jsx
import { $getSelection, $isRangeSelection } from 'lexical';

editor.registerUpdateListener(({ editorState }) => {
  // 必须在 read 或 update 回调中进行
  editorState.read(() => {
    // 1. 获取当前选区
    const selection = $getSelection();

    // 2. 判断选区类型
    if ($isRangeSelection(selection)) {
      // 3. 对选区进行操作
      if (selection.isCollapsed()) {
        console.log('This is a caret (cursor).');
      } else {
        console.log('Selected text:', selection.getTextContent());
      }
      
      // 更新 UI，比如高亮工具栏的 "B" 按钮
      const isBold = selection.hasFormat('bold');
      // setReactStateIsBold(isBold);
    }
  });
});
```
**关键点**：`$getSelection()` 这样的 `$` 函数只能在 `editor.update()` 或 `editorState.read()` 的回调中使用。

#### 2. 修改/设置选区

你通常不直接创建一个全新的 `Selection` 对象然后去“设置”它。更常见的做法是**通过操作节点来间接改变选区**。

节点对象上有很多方便的方法可以移动选区：

-   `node.selectStart()`: 将光标移动到该节点的**开头**。
-   `node.selectEnd()`: 将光标移动到该节点的**结尾**。
-   `node.select()`: 选中**整个**节点。
-   `textNode.select(startOffset, endOffset)`: 选中 `TextNode` 内的特定文本范围。

**示例：在一个命令处理函数中，插入文本后移动光标**
```javascript
editor.registerCommand(INSERT_SPECIAL_TEXT_COMMAND, (payload) => {
  editor.update(() => {
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      // 在当前选区插入文本
      selection.insertText('SPECIAL TEXT');
      // 插入后，光标会自动移动到新文本的末尾
    }
  });
  return true;
});
```

### 总结

| 概念 | 类比 | 解释 |
| :--- | :--- | :--- |
| **`Selection`** | **地图上的 GPS 坐标 / 舞台上的聚光灯** | `EditorState` 的一部分，定义了用户的焦点和操作范围。 |
| **`anchor` & `focus`** | **路线的起点和终点** | 两个点共同定义了选区的范围和方向。 |
| **`RangeSelection`** | **普通导航/路线规划** | 最常见的选区，用于光标和文本高亮。 |
| **`NodeSelection`** | **选中整个“兴趣点”（POI）** | 用于选中图片、表格等不可分割的块。 |
| **`$getSelection()`** | **“查询我当前的 GPS 位置”** | 在事务中获取当前选区对象的方法。 |

理解 `Selection` 是掌握 Lexical 的关键一步。它是连接用户意图和编辑器状态变化的桥梁，几乎所有的富文本功能开发都离不开对它的读取和判断。