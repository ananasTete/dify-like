
`useHistory` 本身是一个 React Hook，它让你可以在 React 组件（比如工具栏）中，轻松地访问和控制 Lexical 的历史记录状态。

---

### 一、核心理念：基于 `EditorState` 快照的历史栈

要理解 `useHistory`，首先要回忆一下 `EditorState` 的**不可变性 (Immutability)**。

-   每当编辑器内容发生变化，Lexical 都会创建一个**全新的 `EditorState` 快照**。
-   旧的 `EditorState` 并不会被销毁，而是被保留了下来。

`History` 插件利用了这一点，在内部维护了两个“堆栈”(Stack)，就像两叠盘子：

1.  **`undoStack` (撤销栈)**：存放着**过去**的所有 `EditorState` 快照。
2.  **`redoStack` (重做栈)**：存放着被你**撤销掉**的 `EditorState` 快照。

**这个过程就像时间旅行：**

1.  **用户输入**：当用户输入一个字符，一个新的 `EditorState` 被创建。`History` 插件会将**旧的** `EditorState` 压入 `undoStack` 栈顶。同时，`redoStack` 会被清空（因为你开辟了一条新的时间线）。
2.  **用户点击“撤销”**：
    -   `History` 插件从 `undoStack` 顶部**取出**一个 `EditorState` (回到过去)。
    -   将当前“被替换掉”的 `EditorState` **压入** `redoStack` 栈顶（以便将来可以重做）。
    -   将取出的旧 `EditorState` 应用为编辑器的新状态。
3.  **用户点击“重做”**：
    -   `History` 插件从 `redoStack` 顶部**取出**一个 `EditorState` (回到未来)。
    -   将当前 `EditorState` **压入** `undoStack` 栈顶。
    -   将取出的新 `EditorState` 应用为编辑器的新状态。

---

### 二、`useHistory` 的作用：连接 UI 和历史栈

`History` 插件在后台默默地管理着这两个栈，但你的 UI 组件（比如工具栏按钮）怎么知道何时可以撤销，又如何触发撤销动作呢？

**`useHistory` Hook 就是这个连接的桥梁。**

它从 `History` 插件中获取当前的**历史状态 (HistoryState)**，并将其暴露给你的 React 组件。

这个 `historyState` 对象通常包含：

-   `undo()`: 一个函数，调用它会执行一次撤销操作。
-   `redo()`: 一个函数，调用它会执行一次重做操作。
-   `canUndo`: 一个布尔值 (`true`/`false`)，表示 `undoStack` 中是否有内容（即撤销按钮是否应该可点击）。
-   `canRedo`: 一个布尔值 (`true`/`false`)，表示 `redoStack` 中是否有内容（即重做按钮是否应该可点击）。

---

### 三、如何使用 `useHistory`

使用 `useHistory` 通常分为两步：

**第一步：在你的编辑器中启用 `History` 插件**

`useHistory` Hook 需要与 `HistoryPlugin` 配合使用。你必须首先在你的编辑器组件树中某个地方渲染 `<HistoryPlugin />`。

```jsx
import { LexicalComposer } from '@lexical/react/LexicalComposer';
import { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';
import { ContentEditable } from '@lexical/react/LexicalContentEditable';
import { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin';

function Editor() {
  // ... initialConfig ...
  return (
    <LexicalComposer initialConfig={initialConfig}>
      {/* ... */}
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
      />
      {/* 启用历史记录功能 */}
      <HistoryPlugin />
    </LexicalComposer>
  );
}
```
`HistoryPlugin` 会自动监听编辑器的更新，并管理历史栈。

**第二步：在你的 UI 组件中使用 `useHistory` Hook**

现在，你可以在任何子组件（比如工具栏）中调用 `useHistory` 来获取控制器。

```jsx
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { useHistory } from '@lexical/react/useHistory';

function Toolbar() {
  const [editor] = useLexicalComposerContext();
  const historyState = useHistory(editor); // 传入 editor 实例

  // 从 historyState 中解构出需要的方法和状态
  const { undo, redo, canUndo, canRedo } = historyState;

  return (
    <div>
      <button 
        onClick={() => undo()} 
        disabled={!canUndo}
        aria-label="Undo"
      >
        Undo
      </button>
      <button 
        onClick={() => redo()} 
        disabled={!canRedo}
        aria-label="Redo"
      >
        Redo
      </button>
    </div>
  );
}
```

**代码解析：**
1.  我们通过 `useLexicalComposerContext()` 获取当前的 `editor` 实例。
2.  将 `editor` 实例传递给 `useHistory(editor)` Hook。
3.  Hook 返回一个包含 `undo`, `redo`, `canUndo`, `canRedo` 的对象。
4.  我们将这些函数和布尔值绑定到按钮的 `onClick` 和 `disabled` 属性上。

这样，一个功能齐全的撤销/重做工具栏就完成了。

---

### 四、智能合并 (Smart Merging)

一个好的撤销/重做体验，不应该在你输入 "hello" 这个单词时产生 5 个撤销步骤。

`HistoryPlugin` 默认实现了**智能合并**逻辑：
-   连续的、没有中断的文本输入会被合并成**一次**历史记录。
-   当用户暂停输入超过一小段时间（比如 1 秒），或者进行了非文本操作（如改变格式、移动光标），下一次的输入就会创建一个**新的**历史记录。

这使得撤销/重做的行为非常符合直觉。

### 总结

| 概念 | 类比 | 解释 |
| :--- | :--- | :--- |
| **`HistoryPlugin`** | **时间机器的引擎** | 在后台默默记录 `EditorState` 快照，管理撤销/重做两个栈。 |
| **`useHistory` Hook**| **时间机器的控制面板** | 为你的 React UI 提供 `undo`, `redo` 等控制按钮，以及 `canUndo` 等状态指示灯。 |
| **`EditorState` 不可变性** | **时间线上固定的快照**| `History` 功能能够可靠工作的基础，因为每个历史点都是一个完整、确定的状态。 |

简而言之，**`useHistory` 是一个让你能够以 React 的方式，轻松地与 Lexical 强大的、基于不可变状态的历史记录引擎进行交互的“遥控器”**。你只需要在编辑器中安装“引擎” (`HistoryPlugin`)，然后在你的 UI 中使用“遥控器” (`useHistory`) 即可。